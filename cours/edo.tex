\documentclass{beamer}
\usepackage{pgfpages}
\usepackage[utf8]{inputenc} % package definissant les propriétés de la langue
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}
\hypersetup{colorlinks=true}
\usepackage{animate}
\usepackage{listings}
\usepackage{multicol}
\usepackage{multimedia}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{scrextend}
\usepackage{setspace}

\usetheme{Madrid}
%\setbeameroption{show notes on second screen}

\definecolor{persgreen}{RGB}{28,140,48}

\makeatletter
\newcommand{\srcsize}{\@setfontsize{\srcsize}{5pt}{5pt}}
\makeatother

\usefonttheme[onlymath]{serif}

\lstdefinelanguage{console}{basicstyle=\small,breaklines=true,tabsize=2, showstringspaces=false}
\lstdefinelanguage{pers_py}{language=Python,basicstyle=\srcsize,breaklines=true,tabsize=2, numbers=left, numbersep=1pt, keywordstyle=\color{blue}\ttfamily,stringstyle=\color{orange}\ttfamily,commentstyle=\color{brown}\ttfamily,morecomment=[l][\color{red}]{!\$}, showstringspaces=false,xleftmargin=5pt}

\setbeamertemplate{navigation symbols}{}

\colorlet{beamer@blendedblue}{gray!40!black}

\title[\textcolor{white}{PAN-2}]{Programmation et Algorithmes numériques 2}
\subtitle[\textcolor{white}{PAN-2}]{\large Intégration numérique d'équations différentielles ordinaires}
\author{D. Cornu}
\date{S4-2019}


\begin{document}


\begin{frame}
\titlepage
\end{frame}


\begin{frame}
\frametitle{Définition}
Un \textcolor{red}{problème différentiel} s'exprime selon une équation différentielle scalaire d'ordre \textcolor{red}{$n$}
\vspace{0.4cm}
\begin{equation*}
	\frac{d^{n}y}{dt^{n}} = f\left( t,y,\frac{dy}{dt},\dots,\frac{d^{n-1}y}{dt^{n-1}} \right)
\end{equation*}
\vspace{0.3cm} 
$f$ est la fonction \textbf{second membre}.\\
\vspace{0.5cm}
Donne une \textbf{famille} de solutions $y(t)$ à \textcolor{red}{$n$} paramètres.\\
\vspace{0.5cm}
Pour résoudre ce type de système il faut donner $n$ conditions imposées\\
$\rightarrow$ nous donne \textbf{une} solution dans la famille
\end{frame}


\begin{frame}
\frametitle{Type de problème}
Conditions initale données pour une seule valeur $t_0$ de $t$ :
\begin{equation*}
	y(t_0) = y_0 , y'(t_0) = y'_0, \dots ,y^{n-1}(t_0)=y_0^{n-1}
\end{equation*}
\textbf{Problème dit de \textcolor{red}{conditions initiales} ou de Cauchy}
\vfill
\hrulefill
\vfill
Conditions données pour des valeurs spécifiques de la variable\\ indépendante $t$ :
\begin{equation*}
	y(t_0) = y_0, y(t_1) = y_1, \dots , y(t_{n-1}) = y_{n-1}
\end{equation*}
\textbf{Problème dit de \textcolor{red}{conditions aux limites}}
\end{frame}


\begin{frame}
\frametitle{Motivation Physique}
La plupart des problèmes physiques conduisent à des (systèmes d') \textbf{\textcolor{red}{équations différentielles}}. \\
\vspace{0.5cm}
\begin{columns}[t]
\footnotesize
\begin{column}{0.28\textwidth}
\textbf{Désintégration radioactive}
\begin{equation*}
\frac{d}{dt}N(t) = -kN(t)
\end{equation*}
$N(t)$ nb d'atomes au temps t\\
C.I : $N(0)=N_0$
\end{column}
%
\begin{column}{0.38\textwidth}
\textbf{Equation d'onde}
\begin{equation*}
\frac{1}{c^2}\frac{d^2}{dt^2}E(x,t) = \frac{d^2}{dx^2}E(x,t)
\end{equation*}
$E(x,t)$ : champ électrique
\end{column}
%
\begin{column}{0.28\textwidth}
\textbf{Mécanique}
\begin{equation*}
m\frac{d^2}{dt^2}x(t) = -kx(t)
\end{equation*}
C.I : $x(0) = x_0$ \& $v(0) = \frac{dx}{dt}_{t=0} = v_0 $
\end{column}
\end{columns}
\vspace{0.8cm}
Très souvent on ne sait pas résoudre ces systèmes de manière analytique :
\hspace{0.4cm} $\rightarrow$ \textcolor{red}{résolution numérique}

\end{frame}

\begin{frame}
\frametitle{Equation différentielle scalaire d'ordre 1}
Le probème général se simplifie dans le cas des EDO du \textcolor{red}{premier ordre}\\
Donne une famille de solution $y(t)$ à \textcolor{red}{un} paramètre $(y_0)$
\begin{equation*}
\frac{dy}{dt} = f(t,y(t))\quad \text{avec} \quad y(t_0) = y_0
\end{equation*}
\vspace{0.4cm}
Dans le cas où le membre de droite ne dépend pas de $y(t)$ on a :
\begin{equation*}
\frac{dy}{dt} = f(t) \quad \text{solution :} \quad y(t) = y_0 + \int_{t_0}^{t}f(t)dt
\end{equation*}
Auquel cas on peut simplement utilisze une méthode d'intégration de type rectangles ou trapèzes, ...
\end{frame}


\begin{frame}
\frametitle{Equation différentielle scalaire d'ordre 1}
\begin{equation*}
\frac{dy}{dt} = f(t,y(t))\quad \text{avec} \quad y(t_0) = y_0
\end{equation*}
Exemple du cas général : particules dans un champ variable
\begin{equation*}
m\frac{dv}{dt} = \sum{\text{forces}} = f(t,v(t))
\end{equation*}
On vois que la force dépend de la vitesse $v$ et que le champ de force dépend explicitement du temps.\\
\vspace{1.2cm}
\textit{Note : un système d'EDO d'ordre supérieur \textcolor{red}{$n$} se ramène à \textbf{des systèmes différentiels couplés} de \textcolor{red}{$n$ équationss} du première ordre $\rightarrow$ EDO vectorielles d'ordre 1}
\end{frame}


\begin{frame}
\frametitle{Résolution Numérique}
Dans le cas d'une résolution numérique, on opère une discrétisation par découpage d'un intervalle $[t_0,t_0+L]$ longueur $L$ selon un pas constant $h$.\\
\vspace{0.3cm}
\textcolor{red}{Echantillonage} aux instants $\bm{ t_i = y_0 + ih}$ pour $ 1 \leqslant i \leqslant n$\\
\vspace{0.5cm}
Numériquement pour un problème avec condition initiale, cela revient à faire une boucle sur les $t_i$ pour calculer l'approximation $u_{i+1}$ à $t_{i+1}$\\
\vspace{0.1cm}
C'est une approximation \textbf{\textcolor{red}{de proche en proche}} de la solution sur l'intervalle $L$.\\
\vspace{0.2cm}
	$\Rightarrow$ accumulation des erreurs dans la boucle, on parle de \textbf{\textcolor{red}{dérive}} ou d'erreur cumulée\\
\vspace{0.6cm} 
- Si calcul sur la dernière valeur calculée $u_i$ : \textbf{méthodes à un pas}\\
- Si calcul sur plusieurs valeurs précédentes $u_{i-k}(k \geqslant 0)$ : \textbf{méthodes à plusieurs pas} \small{(initialisation le plus souvent à un pas)}

\end{frame}


\begin{frame}
\begin{figure}
\includegraphics[width=0.82\textwidth]{images/gen_graph_edo.png}
\end{figure}
\end{frame}



\begin{frame}
\frametitle{Méthodes à un pas}
L'estimation de la fonction au pas suivant se résume à un développement limité de Taylor :
\begin{equation*}
	y(t_i + h) = y(t_i) + h \frac{dy}{dt}(t_i) + \frac{h^2}{2}\frac{d^2y}{dt^2}(t_i) + \dots
\end{equation*}
\textcolor{red}{L'ordre $n$} de la méthode est la plus grande puissance de $h$ prise en compte dans l'approximation.\\
\vspace{0.4cm}
On distingue deux types d'erreur qui se cumulent :\\
\vspace{0.3cm}
\begin{columns}[t]
\small
\begin{column}{0.48\textwidth}
\textcolor{red}{\textbf{Erreur de troncature locale}}\\
\vspace{0.2cm}
- Somme des \textbf{termes négligés} $\propto h^{n+1}$.\\
- Déterministe : Augmente si le pas $h$ augmente et est proportionelle à l'ordre de la méthode $+ 1$
\end{column}
%
\begin{column}{0.48\textwidth}
\textcolor{red}{\textbf{Erreur d'arrondi}}\\
\vspace{0.2cm}
- \textbf{Erreur de précision (finie) des opérations} sur les réels.\\
- "Aleatoire" : Augmente si les calculs se compliquent, augmente pour un pas plus fin ($h$ petit)
\end{column}
\end{columns}

\end{frame}



\begin{frame}
\frametitle{Taille des pas, "résolution/Sampling" de la méthode}
\begin{columns}[t]
\begin{column}{0.3\textwidth}
\begin{figure}
\includegraphics[width=1.0\textwidth]{images/deriv_edo.pdf}
\caption*{Méthode d'ordre 1}
\end{figure}
\end{column}
%
\begin{column}{0.68\textwidth}
La dérive de l'erreur est plus forte si la fonction change rapidement.\\
Il faut adapter la taille du pas $h$ afin de garantir que la fonction soit bien résolue.\\
\vspace{0.4cm}
\textcolor{red}{L'Ordre} de la méthode permet pour \textbf{une même taille de pas} de moins dériver.\\
\vspace{0.3cm}
D'une manière générale on considère que réduire le pas permet une meilleur solution au prix d'un coût de calcul élevé.\\
\vspace{0.3cm}
\textbf{Attention} cepandant à ne pas devenir dominé par les erreurs d'arrondie ! Il sagit en réalité d'un \textcolor{red}{compromis} !
\end{column}
\end{columns}

\end{frame}


\begin{frame}
\frametitle{Méthode d'Euler explicite}
\small
\begin{columns}[t]
\begin{column}{0.43\textwidth}
\begin{figure}
\includegraphics[width=1.0\textwidth]{images/euler_edo.png}
\end{figure}
\end{column}
%
\begin{column}{0.5\textwidth}
On exprime la dérivée comme une dfférence finie :
\begin{align*}
& \frac{dy}{dt} = f(t,y(t)) \approx \frac{y(t+h) - y(t)}{h}\\
& \\
& \frac{u_{i+1} - u_i}{h} = f(t_i,u_i)\\
& \\
& \bm{\Rightarrow u_{i+1} = u_i + hf(t_i,u_i)} \\
\end{align*}
\end{column}
\end{columns}
La méthode d'Euler néglige les termes en $h^2$ $\Rightarrow y(t_i + h) = y(t_i) + h \frac{dy}{dt}(t_i) + O(h^2)$\\
On integre sur $L$ avec un pas $h$ on a donc $L/h$ pas d'intégration $\Rightarrow$ la méthode est donc uniquement \textcolor{red}{d'ordre 1}\\
\vspace{0.3cm}
\footnotesize{Note : Il existe aussi une méthode d'Euler \textbf{Implicite} (ou rétrograde) mais qui nécessite de connaitre une solution analytique de $u_{i+1}$}

\end{frame}


\begin{frame}[fragile]
\frametitle{Exemple de la méthode d'Euler}
Rappel objectif : $\frac{dy}{dt} = f(t,y(t))$\\
\vspace{-0.2cm}
\begin{align*}
& u_{i+1} = u_i + hf(t_i,u_i) \qquad & \text{Solution exacte :} \\
& y'(t) = t + y + 1 & y(t) = 2e^t-t-2
\end{align*}

\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=pers_py, frame=0, numbers=none, basicstyle=\ttfamily\scriptsize]
n = 10    #nb de pas
h = 0.5   #intervalle (dt)

t = 0
y = 0

data = np.zeros((n+1,2))

for i in range(0,n+1):
	t = i * h
	y = y + (t + y + 1) * h
	data[i,0] = t
	data[i,1] = y
...
plot...
\end{lstlisting}
\end{column}
%
\begin{column}{0.55\textwidth}
\begin{figure}[t]
\includegraphics[width=1.0\textwidth]{images/expl_edo_euler.pdf}
\end{figure}
\vfill
\end{column}
\end{columns}
\end{frame}



\begin{frame}
\frametitle{Exemple 2 de la méthode d'Euler}
\small
\vspace{-0.4cm}
Cas d'un projectile lancé avec une vitesse $v_0$ dans un repère $x,y$\\
\vspace{0.1cm}
Position : $\vec{r} = (x,y)$ \hspace{0.4cm} et : $\vec{v} = (v_x, v_y)$
Les équations de newton nous donnent :
\begin{columns}[t]
\begin{column}{0.4\textwidth}
\begin{align*}
& \frac{d}{dt}\vec{r} = \vec{v} \\ 
& \frac{d}{dt}\vec{v} = \frac{\vec{F}}{m}
\end{align*}
\end{column}
%
\begin{column}{0.4\textwidth}
\begin{align*}
& x' = v_x \\
& y' = v_y \\
& v'_x = F_x/m = 0 \\
& v'_y = F_y/m = -g
\end{align*}
\end{column}
\end{columns}
C'est donc un système de \textbf{4 équations différentielles couplées !}\\
Via la méthode d'Euler : $u_{i+1} = u_i + hf(t_i,u_i)$
\vspace{-0.5cm}
\begin{columns}[t]
\begin{column}{0.4\textwidth}
\begin{equation*}
\vec{y} = 
\begin{bmatrix}
x \\
y \\
v_x \\
x_y
\end{bmatrix}
\quad
\vec{f} = 
\begin{bmatrix}
v_x \\
v_y \\
0 \\
-g
\end{bmatrix}
\end{equation*}
\end{column}
%
\begin{column}{0.4\textwidth}
\begin{align*}
& x_{i+1} = x_i + v_x\times h\\
& y_{i+1} = y_i + v_y \times h\\
& v_{x\,i+1} = v_{x\,i} + 0 \times h\\
& v_{y\,i+1} = v_{y\,i} - g \times h
\end{align*}
\end{column}
\end{columns}
\vspace{0.1cm}
\textcolor{red}{Attention :} l'ordre des calculs importe ! Ici il faut bien prendre les vitesses en $i$. \\
\vspace{0.1cm}
\scriptsize{Si on met à jour les vitesses PUIS les positions avec les nouvelles méthode il s'agit d'un \textcolor{red}{leapfrog}}

\end{frame}



\begin{frame}
\frametitle{Méthode d'ordre 2}
Pour \textbf{augmenter l'ordre de la méthode} on va bien évidemment tenter d'ajouter des termes du développement de Taylor :\\
\vspace{0.2cm}
\begin{equation*}
	y(t_i + h) = y(t_i) + h \frac{dy}{dt}(t_i) + \frac{h^2}{2}\frac{d^2y}{dt^2}(t_i) + \dots
\end{equation*}
\begin{equation*}
	\frac{dy}{dt} = f(t, y(t)) \quad \Rightarrow \quad \frac{d^2y}{dt^2} = \frac{\partial f}{\partial t} + \frac{\partial f}{\partial y}\frac{dy}{dt} = \frac{\partial f}{\partial t} + \frac{\partial f}{\partial y} f
\end{equation*}
\vspace{0.2cm}\\
En pratique il est souvent difficile d'obtenir une évaluation correcte des dérivées partielles de $f$ ...\\
\vspace{0.5cm}
On général on preferera une méthode capable d'évaluer \textcolor{red}{\textbf{le second membre de f}} en plusieurs points adaptés.
\begin{equation*}
\Downarrow
\end{equation*}

\end{frame}



\begin{frame}
\frametitle{Méthode du point milieu}
On centre l'évaluation de la \textbf{dérivée} en $t_m = (t_i + t_{i+1})/2$, \\
appelé \textcolor{red}{\textbf{point milieu}} :
\begin{align*}
y(t_i + h) = y(t_m) \textcolor{red}{+ \frac{h}{2}\frac{dy}{dt}(t_m)} + \frac{1}{2}\frac{h^2}{4}\frac{d^2y}{dt^2}(t_m) + O(h^3) \\
y(t_i) = y(t_m) \textcolor{red}{- \frac{h}{2}\frac{dy}{dt}(t_m)} + \frac{1}{2}\frac{h^2}{4}\frac{d^2y}{dt^2}(t_m) + O(h^3) \\
\end{align*}
Par différence entre ces deux termes on trouve la solution suivante :\\
\begin{equation*}
	y(t_i+h) - y(t_i) =\textcolor{red}{h\frac{dy}{dt}(t_m)} + O(h^3)
\end{equation*}
\end{frame}



\begin{frame}
\frametitle{Méthode du point milieu}
Pour parler d'une méthode de second ordre ou doit faire l'évaluation de $f$ en 2 points, en $(t_i,u_i)$ et \textcolor{red}{au milieu} $(t_{i+1/2} = t_i + h/2, u_{i+1/2})$
\begin{equation*}
	u_{i+1} = u_i + hf\left( t_i + \frac{h}{2}, u_i + \frac{h}{2}f(t_i,u_i)\right)
\end{equation*}
On peux alors écrire les coeficients $k_i$ tels que :
\begin{align*}
& \textcolor{blue}{k_1} = f(t_i, u_i)\\
& \textcolor{red}{k_2} = f\left( t_i + \frac{h}{2}, u_i + \textcolor{blue}{k_1}\frac{h}{2} \right)\\
& u_{i+1} = u_i + h\textcolor{blue}{k_2}
\end{align*}
Les termes $\textcolor{blue}{k_1}$ et $\textcolor{red}{k_2}$ sont évalués l'un après l'autre et le dernier d'entre eux permet d'évaluer $u_{i+1}$
\end{frame}



\begin{frame}
\frametitle{Illustration de la méthode du point milieu}
\begin{figure}[t]
\includegraphics[width=0.85\textwidth]{images/point_milieu.png}
\caption{\small Méthode du point milieu selon les notations précédentes}
\end{figure}
\end{frame}



\begin{frame}
\frametitle{Méthode de Runge-Kutta d'ordre 2 (RK2)}
La méthode RK2 (ou Euler Modifée) reprend les equations en $t_i$ et $t_{i+1}$ et fait \textbf{la moyenne des dérivées aux ectrémités} (plutot que la somme). (similaire à la méthode des trapèzes)
\begin{equation*}
	\frac{dy}{dt}(t_i) + \frac{dy}{dt}(t_{i+1}) = 2\frac{dy}{dt}(t_m) + O(h^2)
\end{equation*}
ce qui évite une approximation via le point milieu $t_m$
\begin{equation*}
	u_{i+1} = u_i + \frac{h}{2} \big[ f(t_i,u_i) + f(t_{i+1},u_{i+1})\big]
\end{equation*}
C'est une méthode dite \textbf{implicite}, plus stable que les précédente (mais plus lourde)\\
Le plus souvent on se sert tout de même de la méthode d'euler pour évaluer $u_{i+1}$

\end{frame}




\begin{frame}
\frametitle{Méthode de Runge-Kutta d'ordre 2 (RK2)}
On parle de méthode : \textbf{\textcolor{red}{prédicteur-correcteur}}
\begin{align*}
& \textcolor{blue}{k_1} = f(t_i, u_i)\\
& \textcolor{red}{k_2} = f(t_{i+1}, u_{i+1})\\
& u_{i+1} = u_i + \frac{h}{2}\big[ \textcolor{blue}{k_1} + \textcolor{red}{k_2}\big]
\end{align*}
Revient à faire un demi-pas avec chacune des estimation $u_i$ et $u_{i+1}$ effectuée avec Euler progressif.\\
\vspace{0.3cm}
- C'est une méthode d'ordre 2 comme le point milieu mais pas d'évalution hors grille.
- On peux itérer sur la correction jusqu'à ce que celle-ce devienne négligeable.
\end{frame}


\begin{frame}
\frametitle{Illustration de la méthode RK2}
\begin{figure}[t]
\includegraphics[width=0.8\textwidth]{images/rk2.png}
\caption{\small Méthode RK2 selon les notations précédentes}
\end{figure}
\end{frame}



\begin{frame}
\frametitle{Méthode de RK4}
Les méthodes RK(N) fonctionnent toutes selon le même principe de \textbf{prédiction-correction} mais avec plusieus évaluations en différents points entre $u_i$ et $u_{i+1}$, avec $N$ le nombre d'évaluations nécessaires.\\
\vspace{0.3cm}
$N$ peut être très élevé, pour un coût de calcul de plus en plus important.\\
En pratique la méthode la plus utilisée est \textbf{\textcolor{red}{RK4}} (car la plus polyvalente)\\
\vspace{-0.4cm}
\begin{align*}
& \textcolor{blue}{k_1} = f(t_i, u_i) \\
& \textcolor{red}{k_2} = f\big( t_i + \frac{h}{2}, u_i + \textcolor{blue}{k_1}\frac{h}{2} \big)\\
& \textcolor{persgreen}{k_3} = f\big( t_i + \frac{h}{2}, u_i + \textcolor{red}{k_2}\frac{h}{2} \big)\\
& \textcolor{orange}{k_4} = f\big( t_i + h, u_i + \textcolor{persgreen}{k_3}h \big)\\
& u_{i+1} =(\textcolor{blue}{k_1} + 2\textcolor{red}{k_2} + 2\textcolor{persgreen}{k_3} + \textcolor{orange}{k_4})\frac{h}{6}
\end{align*}

\end{frame}



\begin{frame}
\frametitle{Méthode de Velolcity-Verlet}
\small
\begin{columns}[t]
\begin{column}{0.38\textwidth}
\\
\vspace{-0.05cm}
Algorithme spécifiquement conçu pour l'intégration des \textbf{équations du mouvement} :\\
\vspace{1.0cm}
Développpement de Taylor associé :\\
\vspace{1.55cm}
Différences finies :\\
\vspace{1.25cm}
\textbf{Méthode de Velocity-Verlet}

\end{column}
%
\begin{column}{0.06\textwidth}
\vspace{0.4cm}
\\
$\Rightarrow$\\
\vspace{1.6cm}
$\Rightarrow$\\
\vspace{1.7cm}
$\Rightarrow$\\
\vspace{1.3cm}
$\Rightarrow$
\end{column}
%
\begin{column}{0.53\textwidth}
\vspace{-0.6cm}
\begin{align*}
& \frac{d}{dt}\vec{r} = \vec{v} \\
& \frac{d}{dt}\vec{v} = \frac{\vec{F}\big(t,\vec{r}(t),\vec{v}(t)\big)}{m}
\end{align*}
\vspace{-0.5cm}
\begin{align*}
& \vec{r}(t+h) = \vec{r}(t) + \vec{v}(t)h + \frac{h^2}{2}\vec{a}(t)\\
& \vec{v}(t+h) = \vec{v}(t) + \vec{a}(t)h + \frac{h^2}{2}\frac{d\vec{a}}{dt}
\end{align*}
\vspace{0.cm}
\hrulefill
\begin{equation*}
\frac{d\vec{a}}{dt} = \textcolor{blue}{\frac{\vec{a}(t+h) - \vec{a}}{h}}
\end{equation*}
\vspace{-0.4cm}
\begin{align*}
& \vec{r}(t+h) = \vec{r}(t) + \vec{v}(t)h + \frac{h^2}{2}\vec{a}(t)\\
& \vec{v}(t+h) = \vec{v}(t) + \textcolor{blue}{\frac{\vec{a}(t) + \vec{a}(t+h)}{2}h}
\end{align*}
\end{column}
\end{columns}

\end{frame}


\begin{frame}
\frametitle{Méthode de Velolcity-Verlet}
\begin{align*}
& \vec{r}(t+h) = \vec{r}(t) + \vec{v}(t)h + \frac{h^2}{2}\vec{a}(t)\\
& \vec{v}(t+h) = \vec{v}(t) + \textcolor{blue}{\frac{\vec{a}(t) + \vec{a}(t+h)}{2}}h
\end{align*}
\vspace{0.4cm}
\\
Cet intégrateur est d'ordre 2 sur les vitesses et d'ordre 3 sur les positions.\\
\vspace{0.4cm}
Il est \textit{simple} à programmer. \\
\vspace{0.6cm}
\large
C'est un intégrateur \textbf{\textcolor{red}{symplectique}} : l'évolution des érreurs est périodique $\Rightarrow$ il conserve l'énergie à long terme, \textbf{pas de dérive}.

\end{frame}


\begin{frame}
\frametitle{Erreurs des méthodes précédentes}
\begin{table}[t]
	\small
	\centering
	\begin{tabular}{|l | c | c | c | c |}        
	\hline
	Méthoque & Ordre & Erreur locale & Erreur globale & Symplectique \\
	\hline
	Euler explicite & 1 & $\propto h^2$ & $\propto h$ & non \\
	Point milieu & 2 & $\propto h^3$ & $\propto h^2$ & non \\
	Runge-Kutta 2 & 2 & $\propto h^3$ & $\propto h^2$ & non \\
	Runge-Kutta 3 & 3 & $\propto h^4$ & $\propto h^3$ & non \\
	Runge-kutta 4 & 4 & $\propto h^5$ & $\propto h^4$ & non\\
	Velocity-Verlet & 2+ & $\propto h^3+$ & $\propto h^2+$ & oui \\
	\hline
	\end{tabular}
	\vspace{0.1cm}
	\caption{Table des erreurs de troncature}
	\label{tab_orion_only}
	\end{table}
	\small
	L'erreur \textcolor{red}{d'arrondi} locale est indépendante de $h \rightarrow$ erreur d'arrondi globale $\propto \frac{1}{h}$ 
\end{frame}



\end{document}














